<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Weaver - Mind Structure Game</title>
    <style>
        :root {
            --bg-color: #050510;
            --node-color: #ffffff;
            --line-safe: #00f2ff;
            --line-danger: #ff0055;
            --ui-text: #00f2ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--ui-text);
            pointer-events: none; /* Let clicks pass through to canvas */
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        }

        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .stats {
            font-size: 16px;
            margin-top: 10px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            transition: opacity 0.3s;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        button {
            background: transparent;
            border: 2px solid var(--line-safe);
            color: var(--line-safe);
            padding: 15px 40px;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 20px;
            border-radius: 5px;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.2);
        }

        button:hover {
            background: var(--line-safe);
            color: var(--bg-color);
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.6);
        }

        .status-msg {
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <h1>Neural Weaver</h1>
        <div class="stats">Level: <span id="level-disp">1</span></div>
        <div class="stats">Intersections: <span id="intersect-disp">0</span></div>
        <div class="stats">Time: <span id="time-disp">0</span>s</div>
    </div>

    <div id="overlay">
        <div class="status-msg" id="msg-text">ORGANIZE THE MIND</div>
        <div style="max-width: 400px; text-align: center; margin-bottom: 20px; color: #aaa;">
            Drag the glowing nodes. <br> untangle the lines so none of them cross each other.
        </div>
        <button id="start-btn">Initialize</button>
    </div>

    <canvas id="canvas"></canvas>
</div>

<script>
    /**
     * NEURAL WEAVER ENGINE
     */
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const levelDisplay = document.getElementById('level-disp');
    const intersectDisplay = document.getElementById('intersect-disp');
    const timeDisplay = document.getElementById('time-disp');
    const overlay = document.getElementById('overlay');
    const msgText = document.getElementById('msg-text');
    const startBtn = document.getElementById('start-btn');

    // Game State
    let width, height;
    let nodes = [];
    let connections = [];
    let draggingNode = null;
    let level = 1;
    let startTime;
    let timerInterval;
    let isGameActive = false;
    let particles = [];

    // Configuration
    const NODE_RADIUS = 15;
    const CLICK_TOLERANCE = 30;

    // --- MATH & UTILS ---

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    // Check if two line segments (p1-p2 and p3-p4) intersect
    function getIntersection(p1, p2, p3, p4) {
        // A, B, C are standard form line equation Coeffs
        const det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);
        if (det === 0) return false; // Parallel lines

        const lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;
        const gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;

        return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
    }

    function distance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // --- LEVEL GENERATION ---

    function generateLevel(lvl) {
        nodes = [];
        connections = [];
        
        // Base node count increases with level
        const nodeCount = 4 + lvl;
        
        // 1. Create nodes in a perfect circle first (guarantees planar solution exists)
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 3;

        for (let i = 0; i < nodeCount; i++) {
            const angle = (i / nodeCount) * Math.PI * 2;
            nodes.push({
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius,
                id: i,
                vx: 0, 
                vy: 0
            });
        }

        // 2. Connect neighbors to form a loop
        for (let i = 0; i < nodeCount; i++) {
            connections.push({
                from: i,
                to: (i + 1) % nodeCount,
                intersecting: false
            });
        }

        // 3. Add random internal connections (diagonals) that don't cross in the circle layout
        // For a simple planar graph generation, we can triangulate or add chords carefully.
        // Simplified approach: Add a few chords, but verify they don't cross existing lines in current circle state.
        
        const extraLines = Math.floor(nodeCount * 1.5);
        let attempts = 0;
        while (connections.length < nodeCount + extraLines && attempts < 200) {
            attempts++;
            const a = Math.floor(Math.random() * nodeCount);
            const b = Math.floor(Math.random() * nodeCount);
            
            // Don't connect to self or existing neighbor
            if (a === b || Math.abs(a - b) === 1 || (a === 0 && b === nodeCount - 1) || (a === nodeCount - 1 && b === 0)) continue;

            // Check if connection already exists
            const exists = connections.some(c => (c.from === a && c.to === b) || (c.from === b && c.to === a));
            if (exists) continue;

            // Check if this new line crosses any existing lines in the current layout
            const nodeA = nodes[a];
            const nodeB = nodes[b];
            
            let safe = true;
            for (let c of connections) {
                const n1 = nodes[c.from];
                const n2 = nodes[c.to];
                // Don't check lines that share a start/end point
                if (c.from === a || c.from === b || c.to === a || c.to === b) continue;
                
                if (getIntersection(nodeA, nodeB, n1, n2)) {
                    safe = false;
                    break;
                }
            }

            if (safe) {
                connections.push({ from: a, to: b, intersecting: false });
            }
        }

        // 4. SCRAMBLE! Randomize positions to create the puzzle
        nodes.forEach(node => {
            const margin = 100;
            node.x = margin + Math.random() * (width - margin * 2);
            node.y = margin + Math.random() * (height - margin * 2);
        });

        checkIntersections();
    }

    // --- GAME LOGIC ---

    function checkIntersections() {
        let intersectionCount = 0;
        
        // Reset status
        connections.forEach(c => c.intersecting = false);

        for (let i = 0; i < connections.length; i++) {
            const line1 = connections[i];
            const p1 = nodes[line1.from];
            const p2 = nodes[line1.to];

            for (let j = i + 1; j < connections.length; j++) {
                const line2 = connections[j];
                const p3 = nodes[line2.from];
                const p4 = nodes[line2.to];

                // Skip lines sharing a node
                if (line1.from === line2.from || line1.from === line2.to || 
                    line1.to === line2.from || line1.to === line2.to) continue;

                if (getIntersection(p1, p2, p3, p4)) {
                    line1.intersecting = true;
                    line2.intersecting = true;
                    intersectionCount++;
                }
            }
        }
        
        // We count pairs, but display total collisions roughly
        intersectDisplay.innerText = intersectionCount;
        return intersectionCount;
    }

    function checkWin() {
        if (!draggingNode && checkIntersections() === 0) {
            levelComplete();
        }
    }

    function levelComplete() {
        isGameActive = false;
        clearInterval(timerInterval);
        
        msgText.innerText = "STRUCTURE STABILIZED";
        msgText.style.color = "#00f2ff";
        startBtn.innerText = "Next Structure";
        overlay.classList.remove('hidden');
        level++;
    }

    function startGame() {
        levelDisplay.innerText = level;
        overlay.classList.add('hidden');
        isGameActive = true;
        
        // Timer Reset
        const start = Date.now();
        timerInterval = setInterval(() => {
            const delta = Math.floor((Date.now() - start) / 1000);
            timeDisplay.innerText = delta;
        }, 1000);

        generateLevel(level);
        animate();
    }

    // --- RENDER ---

    function draw() {
        // Clear background
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-color');
        ctx.fillRect(0, 0, width, height);

        // Draw background particles (neural dust)
        ctx.fillStyle = "rgba(0, 242, 255, 0.1)";
        particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            p.y -= p.speed;
            if(p.y < 0) p.y = height;
        });

        // Draw Connections
        ctx.lineWidth = 3;
        connections.forEach(c => {
            const n1 = nodes[c.from];
            const n2 = nodes[c.to];

            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            
            if (c.intersecting) {
                ctx.strokeStyle = "#ff0055"; // Danger Red
                ctx.shadowBlur = 10;
                ctx.shadowColor = "#ff0055";
            } else {
                ctx.strokeStyle = "#00f2ff"; // Safe Cyan
                ctx.shadowBlur = 5;
                ctx.shadowColor = "#00f2ff";
            }
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset
        });

        // Draw Nodes
        nodes.forEach(n => {
            ctx.beginPath();
            ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "#ffffff";
            ctx.fill();
            
            // Node glow
            ctx.beginPath();
            ctx.arc(n.x, n.y, NODE_RADIUS + 5, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255,255,255,0.3)";
            ctx.stroke();
        });
    }

    function animate() {
        if (!isGameActive) return;
        
        checkIntersections(); // Continuously check visual state
        draw();
        
        requestAnimationFrame(animate);
    }

    // --- INPUT HANDLING ---

    canvas.addEventListener('mousedown', (e) => {
        if (!isGameActive) return;
        const { offsetX, offsetY } = e;
        
        // Find clicked node
        for (let n of nodes) {
            if (distance(n, {x: offsetX, y: offsetY}) < CLICK_TOLERANCE) {
                draggingNode = n;
                break;
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!draggingNode || !isGameActive) return;
        
        // Move node
        draggingNode.x = e.offsetX;
        draggingNode.y = e.offsetY;

        // Boundary check
        draggingNode.x = Math.max(NODE_RADIUS, Math.min(width - NODE_RADIUS, draggingNode.x));
        draggingNode.y = Math.max(NODE_RADIUS, Math.min(height - NODE_RADIUS, draggingNode.y));
    });

    canvas.addEventListener('mouseup', () => {
        draggingNode = null;
        checkWin(); // Only check for win on release to prevent jarring level switches while dragging
    });
    
    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
        if (!isGameActive) return;
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        for (let n of nodes) {
            if (distance(n, {x: x, y: y}) < CLICK_TOLERANCE) {
                draggingNode = n;
                break;
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        if (!draggingNode || !isGameActive) return;
        e.preventDefault(); // Stop scrolling
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        
        draggingNode.x = touch.clientX - rect.left;
        draggingNode.y = touch.clientY - rect.top;

        // Boundary
        draggingNode.x = Math.max(NODE_RADIUS, Math.min(width - NODE_RADIUS, draggingNode.x));
        draggingNode.y = Math.max(NODE_RADIUS, Math.min(height - NODE_RADIUS, draggingNode.y));
    }, {passive: false});

    canvas.addEventListener('touchend', () => {
        draggingNode = null;
        checkWin();
    });

    // --- INIT ---
    
    window.addEventListener('resize', resize);
    
    // Initialize Particles
    for(let i=0; i<50; i++) {
        particles.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2,
            speed: 0.5 + Math.random()
        });
    }

    startBtn.addEventListener('click', startGame);
    resize();
    draw(); // Initial draw for background

</script>
</body>
</html>
